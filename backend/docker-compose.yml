services:

  postgres:
    image: postgres:${POSTGRES_VERSION}
    container_name: postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    volumes:
      - ./infrastructure/databases/postgres/config:/docker-entrypoint-inidb.d:ro
      - postgres_data:/var/lib/postgresql/data
    ports:
      - 5432:5432
    healthcheck:
      test:
        - CMD-SHELL
        - pg_isready -U postgres -p 5432
      interval: 10s
      timeout: 5s
      retries: 20
    restart: unless-stopped
    mem_limit: 512m
    mem_reservation: 512m
    networks:
      - services
    
  keycloak-postgres:
    image: postgres:${POSTGRES_VERSION}
    container_name: keycloak-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - ./infrastructure/databases/keycloak-postgres/data:/var/lib/postgresql/data
    ports:
      - 5433:5432
    healthcheck:
      test:
        - CMD-SHELL
        - pg_isready -U keycloak -p 5432
      interval: 10s
      timeout: 5s
      retries: 20
    restart: unless-stopped
    networks:
      - services

  redis:
    image: redis:7
    container_name: redis
    ports:
      - 6379:6379
    volumes:
      - redis_data:/data
    healthcheck:
      test:
        - CMD
        - redis-cli
        - -h
        - localhost
        - -a
        - ping
      interval: 10s
      timeout: 5s
      retries: 20
    restart: unless-stopped
    networks:
      - services

  minio:
    image: minio/minio:latest
    container_name: minio
    environment:
      MINIO_ACCESS_KEY: minioaccesskey
      MINIO_SECRET_KEY: miniosecretkey
    volumes:
      - minio_data:/data
      - ./infrastructure/databases/minio/config:/scripts
    ports:
      - 9000:9000
      - 9001:9001
    entrypoint: /bin/sh -c "minio server /data & /scripts/init-policy.sh && tail -f
      /dev/null"
    healthcheck:
      test:
        - CMD
        - curl
        - -f
        - http://localhost:9000/minio/health/ready
      interval: 10s
      timeout: 5s
      retries: 20
    restart: unless-stopped
    networks:
      - services

  postgres-exporter:
    image: prometheuscommunity/postgres-exporter:latest
    container_name: postgres-exporter
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      DATA_SOURCE_NAME: postgresql://postgres:postgres@postgres:5432/postgres?sslmode=disable
    ports:
      - 9187:9187
    networks:
      - services

  keycloak-postgres-exporter:
    image: prometheuscommunity/postgres-exporter:latest
    container_name: keycloak-postgres-exporter
    depends_on:
      keycloak-postgres:
        condition: service_healthy
    environment:
      DATA_SOURCE_NAME: postgresql://keycloak:keycloak@keycloak-postgres:5432/postgres?sslmode=disable
    ports:
      - 9188:9187
    networks:
      - services
      
  # node-exporter:
  #   image: quay.io/prometheus/node-exporter:latest
  #   container_name: node-exporter
  #   ports:
  #     - 9105:9100
  #   environment:
  #     - TARGET="host.docker.internal"
  #   volumes:
  #     - /:/host
  #   restart: unless-stopped
  #   networks:
  #     - services

  # node-exporter:
  #   image: quay.io/prometheus/node-exporter:latest
  #   container_name: node-exporter
  #   command:
  #     - '--path.rootfs=/host'
  #   network_mode: host
  #   pid: host
  #   restart: unless-stopped
  #   volumes:
  #     - '/:/host:ro,rslave'

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    command:
      - --config.file=/etc/prometheus/prometheus.yml
      - --web.enable-remote-write-receiver
    ports:
      - 9090:9090
    volumes:
      - ./infrastructure/prometheus/config/prometheus.yml:/etc/prometheus/prometheus.yml
    healthcheck:
      test:
        - CMD
        - wget
        - --spider
        - http://localhost:9090/-/healthy
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - services

  loki:
    image: grafana/loki:2.9.2
    container_name: loki
    ports:
      - 3100:3100
    volumes:
      - ./infrastructure/loki/config/loki-config.yaml:/etc/loki/loki-config.yaml:ro
    healthcheck:
      test:
        - CMD
        - wget
        - --spider
        - -q
        - http://localhost:3100/ready
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - services

  alloy:
    image: grafana/alloy:latest
    container_name: alloy
    user: root
    ports:
      - 9080:9080
      - 4317:4317
      - 4318:4318
    volumes:
      - ./infrastructure/alloy/config/config.alloy:/etc/alloy/config.alloy:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/log:/var/log:ro
    depends_on:
      loki:
        condition: service_healthy
    environment:
      GRAFANA_LOKI_URL: http://loki:3100/loki/api/v1/push
    command:
      - run
      - --server.http.listen-addr=0.0.0.0:9080
      - --storage.path=/var/lib/alloy/data
      - /etc/alloy/config.alloy
    networks:
      - services

  grafana:
    image: grafana/grafana:10.3.1
    container_name: grafana
    ports:
      - 3000:3000
    depends_on:
      prometheus:
        condition: service_healthy
      loki:
        condition: service_healthy
    environment:
      GF_AUTH_ANONYMOUS_ENABLED: true
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_METRICS_ENABLED: "true"
    volumes:
      - ./infrastructure/grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./infrastructure/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources:ro
      - grafana_data:/var/lib/grafana
    healthcheck:
      test:
        - CMD
        - curl
        - --fail
        - http://localhost:3000/api/health
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - services

  # prod
  # keycloak:
  #   image: quay.io/keycloak/keycloak:${KC_VERSION}
  #   container_name: keycloak
  #   command:
  #     - start
  #     - --db=postgres
  #     - --import-realm
  #     - --hostname=${DOMAIN_KEYCLOAK}
  #     - --proxy-headers=xforwarded
  #     - --health-enabled=true
  #     - --metrics-enabled=true
  #     - --http-enabled=true
  #     - --http-management-port=9002
  #   restart: unless-stopped
  #   environment:
  #     JAVA_OPTS: >
  #       -Dkeycloak.migration.usersExportStrategy=REALM_FILE
  #       -Dlog.level=DEBUG
  #       -Dkeycloak.events.level=DEBUG
  #       -Dkeycloak.events.enabled=true
  #     KC_DB: postgres
  #     KC_DB_USERNAME: ${POSTGRES_USER}
  #     KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
  #     KC_DB_URL: "jdbc:postgresql://keycloak-postgres:5432/${POSTGRES_DB}"
  #     KEYCLOAK_ADMIN: ${KEYCLOAK_ADMIN}
  #     KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
  #   depends_on:
  #     keycloak-postgres:
  #       condition: service_healthy
  #   volumes:
  #     - ./infrastructure/keycloak/config/realm-config.json:/opt/keycloak/data/import/realm-config.json
  #   healthcheck:
  #     test:
  #       - CMD-SHELL
  #       - curl -fsS http://localhost:9002/health/ready || exit 1
  #     interval: 10s
  #     timeout: 5s
  #     retries: 30
  #   networks:
  #     - services

  # dev
  # keycloak:
  #   image: quay.io/keycloak/keycloak:26.2
  #   container_name: keycloak
  #   command: start-dev --import-realm --metrics-enabled=true --http-management-port=9002
  #   ports:
  #     - 8080:8080
  #     - 9002:9002
  #   environment:
  #     JAVA_OPTS: >
  #       -Dkeycloak.migration.usersExportStrategy=REALM_FILE
  #       -Dlog.level=DEBUG
  #       -Dkeycloak.events.level=DEBUG
  #       -Dkeycloak.events.enabled=true
  #     KEYCLOAK_ADMIN: admin
  #     KEYCLOAK_ADMIN_PASSWORD: admin
  #     KC_DB: postgres
  #     KC_DB_URL: jdbc:postgresql://keycloak-postgres:5432/keycloak
  #     KC_DB_USERNAME: keycloak
  #     KC_DB_PASSWORD: keycloak
  #     KC_METRICS_ENABLED: true
  #     KC_HEALTH_ENABLED: true
  #   volumes:
  #     - ./infrastructure/keycloak/config/realm-config.json:/opt/keycloak/data/import/realm-config.json
  #   depends_on:
  #     keycloak-postgres:
  #       condition: service_healthy
  #   healthcheck:
  #     test:
  #       - CMD-SHELL
  #       - curl -fsS http://localhost:9002/health/ready || exit 1
  #     interval: 10s
  #     timeout: 5s
  #     retries: 30
  #   networks:
  #     - services

  # prod prod
  keycloak:
    build:
      context: ./infrastructure/keycloak/
      dockerfile: Dockerfile
      args:
        KC_VERSION: ${KC_VERSION} 
    container_name: keycloak
    command: ["start", "--optimized", "--import-realm"]
    environment:
      # ====== DATABASE (Keycloak 24+) ======
      KC_DB_URL_HOST: keycloak-postgres
      KC_DB_URL_PORT: 5432
      KC_DB_URL_DATABASE: ${POSTGRES_DB}
      KC_DB_USERNAME: ${POSTGRES_USER}
      KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
      # ... остальные переменные окружения ...
      KEYCLOAK_ADMIN: ${KEYCLOAK_ADMIN}
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
      KC_HOSTNAME: ${DOMAIN_KEYCLOAK}
      KC_PROXY_HEADERS: xforwarded
      KC_HTTP_ENABLED: "true"
      KC_HTTP_MANAGEMENT_PORT: 9002
      # Обязательно добавьте эту переменную, чтобы включить импорт при старте
      KC_IMPORT_REALM: "/opt/keycloak/data/import/keycloak-realms.json"
    depends_on:
      keycloak-postgres:
        condition: service_healthy
    volumes:
      - ./infrastructure/keycloak/config/keycloak-realms.json:/opt/keycloak/data/import/keycloak-realms.json:ro
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:9002/health/ready || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 30
    restart: unless-stopped
    networks:
      - services
    
  nginx:
    image: nginx:latest
    container_name: nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./infrastructure/nginx/nginx-http.conf:/etc/nginx/nginx.conf:ro
      - ./infrastructure/nginx/letsencrypt:/etc/letsencrypt
      - ./infrastructure/nginx/certbot-www:/var/www/certbot
    depends_on:
      - keycloak
    networks:
      - services

  certbot:
    image: certbot/certbot:latest
    container_name: certbot
    volumes:
      - ./infrastructure/nginx/letsencrypt:/etc/letsencrypt
      - ./infrastructure/nginx/certbot-www:/var/www/certbot
    entrypoint: >
      sh -c "
      certbot certonly --webroot -w /var/www/certbot --email ${LETSENCRYPT_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN} --cert-name ${DOMAIN} &&
      certbot certonly --webroot -w /var/www/certbot --email ${LETSENCRYPT_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN_KEYCLOAK} --cert-name ${DOMAIN_KEYCLOAK} &&
      certbot certonly --webroot -w /var/www/certbot --email ${LETSENCRYPT_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN_MINIO} --cert-name ${DOMAIN_MINIO} &&
      certbot certonly --webroot -w /var/www/certbot --email ${LETSENCRYPT_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN_GRAFANA} --cert-name ${DOMAIN_GRAFANA}
      "
      
  spring-boot-app:
    # build:
    #   context: ./application
    #   dockerfile: Dockerfile
    image: spring-boot-app:latest
    container_name: spring-boot-app
    ports:
      - 8888:8888
    environment:
      SPRING_PROFILES_ACTIVE: prod
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    networks:
      - services

volumes:
  postgres_data:
  redis_data:
  minio_data:
  grafana_data:

networks:
  services:
    driver: bridge




# # Elasticsearch Exporter
# docker save prometheuscommunity/elasticsearch-exporter:latest -o elasticsearch-exporter.tar

# # Elasticsearch
# docker save docker.elastic.co/elasticsearch/elasticsearch:8.15.3 -o elasticsearch.tar

# # Локальный образ приложения
# docker build -t spring-boot-app:latest "E:/Projects/projectsIT/Hackathon/Monolith Architecture/monolith-project-v4.0.0/application"
# docker save spring-boot-app:latest -o spring-boot-app.tar




# Передача файлов
# scp spring-boot-app.tar root@178.72.149.213:images/

# # docker-compose.yml
# scp "E:/Projects/projectsIT/Hackathon/Monolith Architecture/monolith-project-v4.0.0/docker-compose.yml" root@178.72.149.213:my_project_prod/

# # .env
# scp "E:/Projects/projectsIT/Hackathon/Monolith Architecture/monolith-project-v4.0.0/.env" root@178.72.149.213:my_project_prod/

# # Папка infrastructure (рекурсивно)
# scp -r "E:/Projects/projectsIT/Hackathon/Monolith Architecture/monolith-project-v4.0.0/infrastructure" root@178.72.149.213:my_project_prod/

# scp -r "E:/Projects/projectsIT/Hackathon/Monolith Architecture/monolith-project-v4.0.0/infrastructure/keycloak/providers" root@178.72.149.213:my_project_prod/infrastructure/keycloak




# Разархивация образов
# cd images

# docker load -i spring-boot-app.tar



# Запуск системы без сертификатов для https
# Делаем скрипт для запуска minio исполняемым: chmod u+x init-policy.sh
# Устанавливаем в nginx конфигурацуию для работы через http: nginx-http.conf
# docker compose up -d --no-deps --build postgres keycloak-postgres redis mongodb minio elasticsearch postgres-exporter keycloak-postgres-exporter redis-exporter mongodb-exporter minio-exporter elasticsearch-exporter node-exporter prometheus loki alloy grafana keycloak spring-boot-app nginx
# docker compose up certbot
# Устанавливаем в nginx конфигурацуию для работы через https: nginx-https.conf
# docker compose up -d






